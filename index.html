<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>IndaiaFibra - Avaliação</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      background: black;
      color: white;
    }

    #spaceCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
      z-index: 0;
      transition: transform 8s cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    .nebula {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 30%, rgba(100, 150, 255, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(255, 100, 150, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 50% 10%, rgba(150, 100, 255, 0.2) 0%, transparent 60%);
      z-index: 1;
      opacity: 0.6;
      animation: nebulaPulse 20s ease-in-out infinite;
    }

    .hyperdrive {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(to bottom, rgba(32, 41, 158, 0.6) 0%, rgba(255, 255, 255, 0.15) 50%, rgba(179, 14, 14, 0.95) 100%),
        repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,0.05) 10px, rgba(255,255,255,0.05) 20px);
      opacity: 0;
      z-index: 2;
      pointer-events: none;
      transition: opacity 0.5s ease-in;
    }

    img {
      width: 150px;
      transform: translateY(100vh) scale(0.7);
      animation: entradaLogo 3.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
      filter: drop-shadow(0 0 30px rgba(21, 94, 183, 1)) brightness(1.5) saturate(2.0) contrast(1.2);
      z-index: 5;
      position: relative;
    }

    .flare {
      position: absolute;
      width: 200px;
      height: 200px;
      background: 
        radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, rgba(255, 200, 100, 0.6) 30%, transparent 70%),
        radial-gradient(ellipse, rgba(100, 200, 255, 0.4) 0%, transparent 50%);
      opacity: 0;
      z-index: 4;
      animation: flareEffect 0.5s ease-out forwards;
      pointer-events: none;
      border-radius: 50%;
    }

    p {
      font-size: 1.6rem;
      margin: 10px 0;
      opacity: 0;
      z-index: 5;
      position: relative;
      letter-spacing: 2px;
      text-align: center;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    #text1 { animation: textoAparece 1.5s ease-out 2.5s forwards; }
    #text2 { animation: textoAparece 1.5s ease-out 3.9s forwards; font-size: 2rem; font-weight: 700; text-shadow: 0 0 20px rgba(21, 94, 183, 0.8); }

    .button-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      margin-top: 20px;
      opacity: 0;
      animation: textoAparece 1.5s ease-out 4.5s forwards;
      z-index: 5;
    }

    button {
      padding: 12px 24px;
      font-size: 1.2rem;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      background: linear-gradient(45deg, #155EB7, #0d47a1);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(21, 94, 183, 0.3), inset 0 1px 0 rgba(255,255,255,0.2);
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      min-width: 200px;
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 8px 25px rgba(21, 94, 183, 0.4), inset 0 1px 0 rgba(255,255,255,0.3);
    }

    button:active {
      transform: translateY(0) scale(0.98);
    }

    #evaluateButton {
      background: linear-gradient(45deg, #28a745, #20c997);
      box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
    }

    #evaluateButton:hover {
      box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
    }

    #playButton {
      display: none;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(221, 221, 221, 1);
      opacity: 0;
      z-index: 10;
      pointer-events: none;
      transition: opacity 1s ease-in;
    }

    #gameOverOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at center, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.95) 100%),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><radialGradient id="g" cx="50%" cy="50%" r="50%"><stop offset="0%" stop-color="%23ff0000" stop-opacity="0.1"/><stop offset="100%" stop-color="%23ff0000" stop-opacity="0"/></radialGradient></defs><circle cx="50" cy="50" r="50" fill="url(%23g)"/></svg>') center/cover;
      z-index: 20;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      font-family: 'Poppins', sans-serif;
      gap: 20px;
      text-align: center;
      padding: 20px;
      opacity: 0;
      transition: opacity 0.8s ease-out;
    }

    #gameOverOverlay h2 {
      font-size: 2.5rem;
      margin: 0 0 10px;
      font-weight: 700;
      text-shadow: 0 0 20px rgba(255,0,0,0.8);
      letter-spacing: 2px;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.6s ease-out;
    }

    #gameOverOverlay p {
      font-size: 1.8rem;
      margin: 0 0 20px;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.8s ease-out;
    }

    #gameOverOverlay.show h2,
    #gameOverOverlay.show p {
      opacity: 1;
      transform: scale(1);
    }

    .score {
      color: #FFD700;
      text-shadow: 0 0 15px #FFD700;
      font-weight: 700;
      font-size: 1.2em;
    }

    #top5 {
      list-style: none;
      padding: 0;
      margin: 10px 0;
      max-width: 300px;
      opacity: 0;
      transform: translateY(30px);
      transition: all 0.5s ease-out;
    }

    #top5 li {
      font-size: 1.2rem;
      margin: 8px 0;
      padding: 5px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      text-align: left;
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
      opacity: 0;
      transform: translateX(-30px) translateY(20px);
      transition: all 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
    }

    #top5.animate-ranking {
      opacity: 1;
      transform: translateY(0);
    }

    #top5.animate-ranking li:nth-child(1) {
      transition-delay: 0.2s;
      opacity: 1;
      transform: translateX(0) translateY(0);
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
    }

    #top5.animate-ranking li:nth-child(2) {
      transition-delay: 0.3s;
      opacity: 1;
      transform: translateX(0) translateY(0);
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
    }

    #top5.animate-ranking li:nth-child(3) {
      transition-delay: 0.4s;
      opacity: 1;
      transform: translateX(0) translateY(0);
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
    }

    #top5.animate-ranking li:nth-child(4) {
      transition-delay: 0.5s;
      opacity: 1;
      transform: translateX(0) translateY(0);
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
    }

    #top5.animate-ranking li:nth-child(5) {
      transition-delay: 0.6s;
      opacity: 1;
      transform: translateX(0) translateY(0);
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
    }

    #top5 li:nth-child(1)::before {
      content: '🥇 ';
      font-size: 1.1em;
    }

    #top5 li:nth-child(2)::before {
      content: '🥈 ';
      font-size: 1.1em;
    }

    #top5 li:nth-child(3)::before {
      content: '🥉 ';
      font-size: 1.1em;
    }

    #nameInput {
      display: none;
      flex-direction: column;
      gap: 10px;
      margin: 10px 0;
    }

    #nameInput input {
      padding: 10px;
      font-size: 1rem;
      border: none;
      border-radius: 15px;
      width: 200px;
      max-width: 80%;
      background: rgba(255, 255, 255, 0.9);
      color: black;
      font-family: 'Poppins', sans-serif;
    }

    #nameInput button {
      padding: 10px 20px;
      font-size: 1rem;
      min-width: auto;
      width: auto;
    }

    .success-message {
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
      color: #00ff00;
      font-size: 1.2rem;
      font-weight: 600;
      text-align: center;
      text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      margin: 10px 0;
    }

    .success-message.show {
      opacity: 1;
      transform: scale(1);
    }

    #gameOverOverlay button {
      padding: 12px 24px;
      font-size: 1.1rem;
      font-weight: 600;
      background: linear-gradient(45deg, #155EB7, #0d47a1);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      margin: 0 5px;
      min-width: auto;
      box-shadow: 0 4px 15px rgba(21, 94, 183, 0.3);
      transition: all 0.3s ease;
      opacity: 0;
      transform: translateY(20px);
    }

    #gameOverOverlay.show button {
      opacity: 1;
      transform: translateY(0);
      transition-delay: 0.8s;
    }

    #gameOverOverlay button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(21, 94, 183, 0.4);
    }

    #gameOverOverlay button:nth-child(3) {
      background: linear-gradient(45deg, #6c757d, #495057);
      box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
    }

    #gameOverOverlay button:nth-child(3):hover {
      box-shadow: 0 6px 20px rgba(108, 117, 125, 0.4);
    }

    #gameOverOverlay button:nth-child(4) {
      background: linear-gradient(45deg, #28a745, #20c997);
      box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
    }

    #gameOverOverlay button:nth-child(4):hover {
      box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
    }

    @media (max-width: 768px) {
      .button-container {
        flex-direction: column;
        gap: 10px;
      }

      button {
        font-size: 1.4rem;
        padding: 15px 30px;
        min-width: 250px;
      }

      #playButton {
        display: block;
      }

      #gameOverOverlay button {
        font-size: 1.3rem;
        padding: 15px 30px;
        margin: 5px 0;
        width: 80%;
      }

      #gameOverOverlay {
        gap: 15px;
        padding: 10px;
      }

      #gameOverOverlay h2 {
        font-size: 2rem;
      }

      #gameOverOverlay p {
        font-size: 1.5rem;
      }

      #top5 li {
        font-size: 1.1rem;
      }

      #nameInput input {
        width: 250px;
        max-width: 90%;
      }

      .success-message {
        font-size: 1.4rem;
      }
    }

    .rastro {
      position: absolute;
      width: 100px;
      height: 350px;
      background: linear-gradient(to top, rgba(255, 230, 100, 0), rgba(0, 139, 255, 0.8), rgba(255, 50, 50, 1));
      border-radius: 100px 100px 50px 50px;
      filter: blur(120px);
      z-index: 6;
      opacity: 1;
      animation: pulsoRastro 1s ease-in-out infinite;
      pointer-events: none;
    }

    .rastro-core {
      position: absolute;
      width: 20px;
      height: 300px;
      background: linear-gradient(to top, rgba(50, 194, 255, 0.79), rgba(255, 4, 4, 1));
      border-radius: 40px;
      filter: blur(40px);
      z-index: 6;
      opacity: 1;
      animation: pulsoRastroCore 0.5s ease-in-out infinite;
      pointer-events: none;
    }

    @keyframes entradaLogo {
      0% { transform: translateY(100vh) scale(0.7); opacity: 0; }
      40% { transform: translateY(30px) scale(1.3); opacity: 1; }
      60% { transform: translateY(-20px) scale(0.95); }
      100% { transform: translateY(0) scale(1); }
    }

    @keyframes textoAparece {
      0% { opacity: 0; transform: translateY(40px); filter: blur(8px); }
      50% { opacity: 0.8; transform: translateY(0); filter: blur(0); }
      100% { opacity: 1; transform: translateY(0); filter: blur(0); }
    }

    @keyframes zoomLogo {
      0% { transform: translateY(0) scale(1); filter: brightness(1.3); }
      100% { transform: translateY(-120vh) scale(0.25); filter: brightness(2.5) drop-shadow(0 0 70px rgba(255, 150, 50, 1)); }
    }

    @keyframes pulsoRastro {
      0% { opacity: 0.9; transform: scaleY(1) scaleX(1); }
      50% { opacity: 1; transform: scaleY(1.3) scaleX(0.8); }
      100% { opacity: 0.9; transform: scaleY(1) scaleX(1); }
    }

    @keyframes pulsoRastroCore {
      0% { opacity: 0.95; transform: scaleY(1); }
      50% { opacity: 1; transform: scaleY(1.25); }
      100% { opacity: 0.95; transform: scaleY(1); }
    }

    @keyframes cameraZoom {
      0% { transform: scale(1); }
      100% { transform: scale(2); }
    }

    @keyframes nebulaPulse {
      0% { opacity: 0.6; transform: scale(1) rotate(0deg); }
      25% { opacity: 0.7; transform: scale(1.02) rotate(1deg); }
      50% { opacity: 0.6; transform: scale(1) rotate(0deg); }
      75% { opacity: 0.65; transform: scale(1.01) rotate(-1deg); }
      100% { opacity: 0.6; transform: scale(1) rotate(0deg); }
    }

    @keyframes flareEffect {
      0% { opacity: 0.9; transform: scale(0.1) rotate(0deg); }
      50% { opacity: 0.5; transform: scale(1.2) rotate(180deg); }
      100% { opacity: 0; transform: scale(2) rotate(360deg); }
    }

    @keyframes flameFlicker {
      0%, 100% { transform: scale(1) rotate(-2deg); opacity: 0.8; }
      50% { transform: scale(1.2) rotate(2deg); opacity: 1; }
    }

    @keyframes powerUpPulse {
      0% { transform: scale(1); box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); }
      50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(0, 255, 255, 0.8); }
      100% { transform: scale(1); box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); }
    }

    @keyframes logoFlyover {
      0% {
        transform: translate(0, 100vh) scale(0.5) rotate(0deg);
        opacity: 0;
        filter: drop-shadow(0 0 10px rgba(21, 94, 183, 0.5));
      }
      30% {
        transform: translate(20vw, 70vh) scale(0.8) rotate(10deg);
        opacity: 1;
        filter: drop-shadow(0 0 20px rgba(21, 94, 183, 0.8));
      }
      70% {
        transform: translate(-20vw, 30vh) scale(1.2) rotate(-5deg);
        opacity: 1;
        filter: drop-shadow(0 0 30px rgba(21, 94, 183, 1));
      }
      100% {
        transform: translate(0, -100vh) scale(0.5) rotate(0deg);
        opacity: 0;
        filter: drop-shadow(0 0 10px rgba(21, 94, 183, 0.5));
      }
    }

    .powerup {
      position: absolute;
      border-radius: 50%;
      animation: powerUpPulse 2s ease-in-out infinite;
    }
  </style>
</head>
<body>
  <canvas id="spaceCanvas"></canvas>
  <div class="nebula"></div>
  <div class="hyperdrive" id="hyperdrive"></div>
  <div class="rastro" id="rastro"></div>
  <div class="rastro-core" id="rastroCore"></div>
  <div class="flare" id="flare"></div>
  <img id="logo" src="logo.png" alt="IndaiaFibra Logo">
  <p id="text1">Avalie nosso serviço</p>
  <p id="text2">Obrigado!</p>
  <div class="button-container">
    <button id="evaluateButton" onclick="triggerExitSequence()">Avaliar Agora</button>
    <button id="playButton" onclick="startGame()">Jogar</button>
  </div>
  <div class="overlay" id="overlay"></div>
  <div id="gameOverOverlay">
    <h2>Game Over!</h2>
    <p>PONTUAÇÃO: <span class="score">0</span></p>
    <ul id="top5"></ul>
    <div id="nameInput"></div>
    <button onclick="restartGame()">Jogar Novamente</button>
    <button onclick="exitGame()">Sair do Jogo</button>
    <button onclick="triggerExitSequence()">Avaliar Serviço</button>
  </div>

  <!-- Sons de fundo e efeitos -->
  <audio id="ambientSound" src="ambient.mp3" loop volume="0.3"></audio>
  <audio id="shootSound" src="shoot.mp3" preload="auto"></audio>
  <audio id="explosionSound" src="explosion.mp3" preload="auto"></audio>
  <audio id="powerupSound" src="powerup.mp3" preload="auto"></audio>
  <audio id="shieldSound" src="shield.mp3" preload="auto"></audio>
  <audio id="hitSound" src="hit.mp3" preload="auto"></audio>
  <audio id="thrustSound" src="thrust.mp3" loop preload="auto"></audio>
  <audio id="ammoRegenSound" src="ammo_regen.mp3" preload="auto"></audio> <!-- Novo som para regeneração de munição -->
  <audio id="downgradeSound" src="downgrade.mp3" preload="auto"></audio> <!-- Novo som para regressão de modelo de tiro -->

  <script>
    const canvas = document.getElementById('spaceCanvas');
    const ctx = canvas.getContext('2d');
    const logo = document.getElementById('logo');
    const rastro = document.getElementById('rastro');
    const rastroCore = document.getElementById('rastroCore');
    const flare = document.getElementById('flare');
    const overlay = document.getElementById('overlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const buttonContainer = document.querySelector('.button-container');
    const pageStartTime = Date.now();
    let rafIdStars, rafIdParticles, rafIdGame;
    let hyperdriveActive = false;
    let gameActive = false;
    let lastTime = 0;
    const shipImg = new Image();
    shipImg.src = 'logo.png';
    let shipX, shipY, shipWidth = 120, shipHeight = 120;
    let score = 0;
    let lives = 5;
    let ammo = 3;
    const maxAmmo = [0, 20, 10, 5, 3]; // Modelo 1:20, 2:10, 3:5, 4:3
    let destroyedMeteors = 0;
    let lastAmmoRegen = Date.now();
    let ammoRegenInterval = 3000;
    let downgradeFlash = 0;
    let gameStartTime;
    let keys = {};
    let asteroids = [];
    let powerups = [];
    let bullets = [];
    let lasers = []; // Novo para lasers do modelo 4
    let thrustParticles = [];
    let explosionParticles = [];
    let asteroidFlames = [];
    let powerUpLevel = 4; // Inicia com modelo 4 (laser, melhor)
    let baseSpeed = 4;
    let currentSpeed = baseSpeed;
    let shieldActive = false;
    let shieldCount = 0;
    let speedBoostEndTime = 0;
    let touchActive = false;
    let doubleClickTimer = 0;
    let difficultyLevel = 0;
    let asteroidSpawnRate = 0.03;
    let maxAsteroidSpeed = 6;
    let lastDifficultyIncrease = 0;
    let isThrusting = false;
    let wasMoving = false;

    const API_URL = 'https://68f458d8b16eb6f46834542c.mockapi.io/Rexord/Pomtos';

    // Sons
    const ambientSound = document.getElementById('ambientSound');
    const shootSound = document.getElementById('shootSound');
    const explosionSound = document.getElementById('explosionSound');
    const powerupSound = document.getElementById('powerupSound');
    const shieldSound = document.getElementById('shieldSound');
    const hitSound = document.getElementById('hitSound');
    const thrustSound = document.getElementById('thrustSound');
    const ammoRegenSound = document.getElementById('ammoRegenSound');
    const downgradeSound = document.getElementById('downgradeSound');

    // Função para tocar som
    function playSound(sound) {
      sound.currentTime = 0;
      sound.volume = 0.5;
      sound.play().catch(e => console.log('Erro ao tocar som:', e));
    }

    // Cores para o rastro baseadas no powerUpLevel
    const trailColors = {
      0: { fire: 'hsl(20, 100%, 50%)', smoke: 'hsl(20, 20%, 50%)' },
      1: { fire: 'hsl(200, 100%, 50%)', smoke: 'hsl(200, 50%, 60%)' },
      2: { fire: 'hsl(60, 100%, 50%)', smoke: 'hsl(60, 50%, 70%)' },
      3: { fire: 'hsl(340, 100%, 50%)', smoke: 'hsl(340, 50%, 60%)' },
      4: { fire: 'hsl(0, 100%, 60%)', smoke: 'hsl(0, 50%, 50%)' }
    };

    // Função para vibração em dispositivos móveis
    function vibrate(duration = 100) {
      if ('vibrate' in navigator && window.matchMedia('(pointer: coarse)').matches) {
        navigator.vibrate(duration);
      }
    }

    async function fetchScores() {
      try {
        const res = await fetch(API_URL);
        if (!res.ok) return [];
        return await res.json();
      } catch (e) {
        console.error('Erro ao buscar scores:', e);
        return [];
      }
    }

    async function saveScore(name, score) {
      try {
        await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, score })
        });
      } catch (e) {
        console.error('Erro ao salvar score:', e);
        alert('Erro ao salvar score. Tente novamente.');
      }
    }

    async function fetchTop5(currentScore, showInput = true) {
      const scores = await fetchScores();
      const top = scores.sort((a, b) => b.score - a.score).slice(0, 5);
      const topList = document.getElementById('top5');
      topList.innerHTML = top.length ? top.map((s, i) => `<li>${i + 1}. ${s.name}: ${s.score}</li>`).join('') : '<li>Nenhum recorde ainda</li>';

      const fifthScore = top[4]?.score || 0;
      if (showInput && (currentScore > fifthScore || top.length < 5)) {
        let inputDiv = document.getElementById('nameInput');
        if (!inputDiv.children.length) {
          inputDiv.innerHTML = `
            <p style="font-size: 1.2rem; margin: 0;">Novo recorde! Insira seu nome:</p>
            <input type="text" id="nameField" placeholder="Seu nome" maxlength="15">
            <button onclick="saveNewScore(${currentScore})">Salvar Score</button>
          `;
        }
        inputDiv.style.display = 'block';
      } else {
        document.getElementById('nameInput').style.display = 'none';
      }

      setTimeout(() => {
        topList.classList.add('animate-ranking');
      }, 100);
    }

    function saveNewScore(currentScore) {
      const name = document.getElementById('nameField').value.trim();
      if (!name) {
        alert('Nome é obrigatório!');
        return;
      }
      saveScore(name, currentScore).then(() => {
        const inputDiv = document.getElementById('nameInput');
        
        const successMsg = document.createElement('p');
        successMsg.className = 'success-message';
        successMsg.innerHTML = '✅ Score salvo com sucesso!';
        successMsg.style.opacity = '0';
        successMsg.style.transform = 'scale(0.8)';
        
        inputDiv.innerHTML = '';
        inputDiv.appendChild(successMsg);
        inputDiv.style.display = 'block';
        
        setTimeout(() => {
          successMsg.classList.add('show');
        }, 10);
        
        setTimeout(() => {
          successMsg.style.opacity = '0';
          successMsg.style.transform = 'scale(1.1)';
          setTimeout(() => {
            inputDiv.removeChild(successMsg);
            inputDiv.innerHTML = '';
            inputDiv.style.display = 'none';
            fetchTop5(currentScore, false);
          }, 500);
        }, 1500);
      });
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const stars = Array.from({ length: 500 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * 2 + 0.3,
      speed: Math.random() * 1 + 0.2,
      brightness: Math.random() * 0.5 + 0.5,
      layer: Math.random() < 0.4 ? 'distant' : Math.random() < 0.6 ? 'mid' : 'near',
      isHyper: false
    }));

    function drawStars() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let s of stars) {
        ctx.fillStyle = s.layer === 'distant' ? '#888' : s.layer === 'mid' ? '#bbb' : '#fff';
        ctx.globalAlpha = s.brightness;
        if (hyperdriveActive && s.isHyper) {
          ctx.beginPath();
          ctx.moveTo(s.x, s.y);
          ctx.lineTo(s.x, s.y + s.size * 20);
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.lineWidth = s.size * 2;
          ctx.lineCap = 'round';
          ctx.stroke();
          s.y += s.speed * 15;
        } else {
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.layer === 'distant' ? s.size * 0.5 : s.layer === 'mid' ? s.size * 0.8 : s.size, 0, Math.PI * 2);
          ctx.fill();
          s.y += s.layer === 'distant' ? s.speed * 0.5 : s.layer === 'mid' ? s.speed * 0.8 : s.speed;
        }
        if (s.y > canvas.height) s.y = 0;
      }
      ctx.globalAlpha = 1;
      rafIdStars = requestAnimationFrame(drawStars);
    }

    const particles = [];
    function createParticle(x, y, isSmoke = false, customColor = null) {
      const color = customColor || (isSmoke ? `hsl(0, 0%, ${Math.random() * 20 + 50}%)` : `hsl(${Math.random() * 40 + 20}, 100%, ${Math.random() * 30 + 50}%)`);
      particles.push({
        x: x + (Math.random() * 50 - 25),
        y: y,
        alpha: 1,
        size: isSmoke ? Math.random() * 20 + 10 : Math.random() * 6 + 3,
        vx: isSmoke ? Math.random() * 2 - 1 : Math.random() * 4 - 2,
        vy: isSmoke ? Math.random() * 2 + 1 : Math.random() * 8 + 4,
        color: color,
        decay: isSmoke ? Math.random() * 0.01 + 0.005 : Math.random() * 0.03 + 0.02,
        rotation: Math.random() * Math.PI * 2,
        isSmoke
      });
    }

    function updateParticles() {
      const rect = logo.getBoundingClientRect();
      for (let i = 0; i < 3; i++) createParticle(rect.left + rect.width / 2, rect.bottom - 5);
      for (let i = 0; i < 2; i++) createParticle(rect.left + rect.width / 2, rect.bottom - 5, true);

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= p.decay;
        p.size *= p.isSmoke ? 0.98 : 0.95;
        p.vy += 0.1;
        p.rotation += p.isSmoke ? 0.05 : 0.1;
        if (p.alpha <= 0 || p.size <= 0.1 || p.y > canvas.height) particles.splice(i, 1);
      }

      particles.forEach(p => {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.alpha;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 5;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
        if (!p.isSmoke && Math.random() < 0.2) {
          ctx.fillStyle = 'white';
          ctx.globalAlpha = p.alpha * 0.7;
          ctx.fillRect(-p.size / 4, -p.size / 4, p.size / 2, p.size / 2);
        }
        ctx.restore();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      rastro.style.left = `${rect.left + rect.width / 2 - 50}px`;
      rastro.style.top = `${rect.bottom}px`;
      rastroCore.style.left = `${rect.left + rect.width / 2 - 10}px`;
      rastroCore.style.top = `${rect.bottom}px`;

      rafIdParticles = requestAnimationFrame(updateParticles);
    }

    function createThrustParticle(x, y) {
      const colors = trailColors[powerUpLevel] || trailColors[0];
      for (let i = 0; i < 3; i++) {
        thrustParticles.push({
          x: x + Math.random() * 20 - 10,
          y: y + shipHeight,
          vx: (Math.random() - 0.5) * 5,
          vy: Math.random() * 4 + 3,
          size: Math.random() * 10 + 4,
          alpha: 1,
          color: colors.fire,
          decay: 0.04,
          life: 35,
          glow: true
        });
      }
      for (let i = 0; i < 4; i++) {
        thrustParticles.push({
          x: x + Math.random() * 20 - 10,
          y: y + shipHeight,
          vx: (Math.random() - 0.5) * 3,
          vy: Math.random() * 3 + 1.5,
          size: Math.random() * 8 + 3,
          alpha: 0.8,
          color: colors.smoke,
          decay: 0.025,
          life: 45,
          trail: true
        });
      }
    }

    function updateThrustParticles() {
      for (let i = thrustParticles.length - 1; i >= 0; i--) {
        const p = thrustParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.15;
        p.alpha -= p.decay;
        p.size *= 0.97;
        p.life--;
        if (p.alpha <= 0 || p.life <= 0 || p.y > canvas.height) {
          thrustParticles.splice(i, 1);
        }
      }
    }

    function drawThrustParticles() {
      thrustParticles.forEach(p => {
        ctx.save();
        if (p.glow) {
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 10;
        }
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        if (p.trail && Math.random() < 0.3) {
          ctx.globalAlpha = p.alpha * 0.5;
          ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
          ctx.beginPath();
          ctx.arc(p.x - p.vx * 2, p.y - p.vy * 2, p.size * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      });
      ctx.shadowBlur = 0;
    }

    function createExplosion(x, y, count = 8) {
      for (let i = 0; i < count; i++) {
        explosionParticles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 10,
          vy: (Math.random() - 0.5) * 10,
          size: Math.random() * 6 + 3,
          alpha: 1,
          color: `hsl(20, 30%, ${Math.random() * 20 + 30}%)`,
          decay: 0.05,
          life: 30,
          glow: true
        });
      }
    }

    function updateExplosionParticles() {
      for (let i = explosionParticles.length - 1; i >= 0; i--) {
        const p = explosionParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.98;
        p.vy *= 0.98;
        p.alpha -= p.decay;
        p.size *= 0.95;
        p.life--;
        if (p.alpha <= 0 || p.life <= 0) {
          explosionParticles.splice(i, 1);
        }
      }
    }

    function drawExplosionParticles() {
      explosionParticles.forEach(p => {
        ctx.save();
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 8;
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
      ctx.shadowBlur = 0;
    }

    function createAsteroidFlame(a) {
      if (!a.flames) a.flames = [];
      for (let i = 0; i < 3; i++) {
        a.flames.push({
          x: a.x + (Math.random() - 0.5) * a.size,
          y: a.y + a.size / 2,
          vx: (Math.random() - 0.5) * 2,
          vy: Math.random() * -2 - 1,
          size: Math.random() * 4 + 2,
          alpha: Math.random() * 0.5 + 0.5,
          color: `hsl(${20 + Math.random() * 40}, 100%, ${50 + Math.random() * 30}%)`,
          life: 20 + Math.random() * 10
        });
      }
    }

    function updateAsteroidFlames() {
      asteroids.forEach(a => {
        if (a.flames) {
          for (let i = a.flames.length - 1; i >= 0; i--) {
            const f = a.flames[i];
            f.x += f.vx;
            f.y += f.vy;
            f.vy += 0.1;
            f.alpha -= 0.05;
            f.life--;
            if (f.alpha <= 0 || f.life <= 0) {
              a.flames.splice(i, 1);
            }
          }
          if (Math.random() < 0.3) createAsteroidFlame(a);
        } else {
          createAsteroidFlame(a);
        }
      });
    }

    function drawAsteroidFlames() {
      asteroids.forEach(a => {
        if (a.flames) {
          a.flames.forEach(f => {
            ctx.save();
            ctx.globalAlpha = f.alpha;
            ctx.fillStyle = f.color;
            ctx.shadowColor = f.color;
            ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.ellipse(f.x, f.y, f.size, f.size * 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          });
        }
      });
      ctx.shadowBlur = 0;
    }

    // Função para atirar baseada no modelo
    function shoot() {
      if (powerUpLevel === 0) return;

      if (ammo <= 0) {
        if (powerUpLevel > 1) {
          powerUpLevel--;
          ammo = maxAmmo[powerUpLevel];
          playSound(downgradeSound);
          vibrate(80);
          downgradeFlash = 30;
          for (let k = 0; k < 12; k++) {
            createParticle(shipX + shipWidth / 2, shipY + shipHeight / 2, false, '#ff0000');
          }
          createExplosion(shipX + shipWidth / 2, shipY + shipHeight / 2, 6);
        } else {
          return;
        }
      }

      ammo--;

      const shipCenterX = shipX + shipWidth / 2;
      const shipCenterY = shipY;
      const baseSpeed = 10 + powerUpLevel * 2;
      const baseSize = powerUpLevel;
      let color;
      switch (powerUpLevel) {
        case 1: color = '#ffffff'; break;
        case 2: color = '#ffff00'; break;
        case 3: color = '#ff00ff'; break;
        case 4: color = '#00ff00'; break;
        default: color = '#ffffff';
      }

      if (powerUpLevel === 1) {
        // Modelo 1: Tiro único fino para cima
        bullets.push({
          x: shipCenterX,
          y: shipCenterY,
          vx: 0,
          vy: -baseSpeed,
          size: baseSize,
          color: color
        });
      } else if (powerUpLevel === 2) {
        // Modelo 2: 2 tiros paralelos para cima, calibre mais grosso
        const offset = 15;
        bullets.push({
          x: shipCenterX - offset,
          y: shipCenterY,
          vx: 0,
          vy: -baseSpeed,
          size: baseSize,
          color: color
        });
        bullets.push({
          x: shipCenterX + offset,
          y: shipCenterY,
          vx: 0,
          vy: -baseSpeed,
          size: baseSize,
          color: color
        });
      } else if (powerUpLevel === 3) {
        // Modelo 3: 3 tiros - um no meio, dois em diagonal para cima
        bullets.push({
          x: shipCenterX,
          y: shipCenterY,
          vx: 0,
          vy: -baseSpeed,
          size: baseSize,
          color: color
        });
        const angle = Math.PI / 9; // ~20 graus
        const sideVx = Math.sin(angle) * baseSpeed;
        const upVy = Math.cos(angle) * baseSpeed;
        bullets.push({
          x: shipCenterX,
          y: shipCenterY,
          vx: -sideVx,
          vy: -upVy,
          size: baseSize,
          color: color
        });
        bullets.push({
          x: shipCenterX,
          y: shipCenterY,
          vx: sideVx,
          vy: -upVy,
          size: baseSize,
          color: color
        });
      } else if (powerUpLevel === 4) {
        // Modelo 4: Varredura horizontal laser verde de baixo para cima
        lasers.push({
          x: 0,
          y: shipY,
          width: canvas.width,
          height: 8,
          speed: 20,
          color: color
        });
      }

      playSound(shootSound);
      vibrate(30 + powerUpLevel * 10);
    }

    function startGame() {
      if (gameActive) return;
      gameActive = true;
      buttonContainer.style.display = 'none';
      logo.style.opacity = '0';
      logo.style.animation = 'none'; // Reset animação
      logo.style.position = 'relative'; // Reset posição
      logo.style.left = 'auto';
      logo.style.top = 'auto';
      logo.style.zIndex = '5';
      document.querySelector('#text1').style.display = 'none';
      document.querySelector('#text2').style.display = 'none';
      flare.style.opacity = '0';
      cancelAnimationFrame(rafIdStars);
      cancelAnimationFrame(rafIdParticles);
      particles.length = 0;
      thrustParticles.length = 0;
      explosionParticles.length = 0;
      asteroidFlames = [];
      lasers = [];
      shipX = (canvas.width - shipWidth) / 2;
      shipY = canvas.height - shipHeight - 50;
      score = 0;
      lives = 5;
      powerUpLevel = 4;
      ammo = maxAmmo[powerUpLevel];
      destroyedMeteors = 0;
      lastAmmoRegen = Date.now();
      downgradeFlash = 0;
      shieldCount = 0;
      asteroids = [];
      powerups = [];
      bullets = [];
      gameStartTime = Date.now();
      lastDifficultyIncrease = gameStartTime;
      difficultyLevel = 0;
      asteroidSpawnRate = 0.01;
      maxAsteroidSpeed = 2;
      keys = {};
      currentSpeed = baseSpeed;
      shieldActive = false;
      speedBoostEndTime = 0;
      isThrusting = false;
      wasMoving = false;
      lastTime = performance.now();
      ambientSound.play().catch(e => console.log('Erro ao tocar som ambiente:', e));
      gameLoop(lastTime);
    }

    function gameLoop(currentTime) {
      if (!gameActive) {
        rafIdGame = requestAnimationFrame(gameLoop);
        return;
      }
      const deltaTime = (currentTime - lastTime) / 16.67;
      lastTime = currentTime;

      const gameTime = Date.now() - gameStartTime;
      const newLevel = Math.floor(gameTime / 10000);
      if (newLevel > difficultyLevel) {
        difficultyLevel = newLevel;
        asteroidSpawnRate += 0.005;
        maxAsteroidSpeed += 1;
      }

      if (Date.now() > speedBoostEndTime) currentSpeed = baseSpeed;
      else currentSpeed = baseSpeed * 1.5;

      shieldActive = shieldCount > 0;

      if (downgradeFlash > 0) {
        downgradeFlash--;
      }

      const now = Date.now();
      if (now - lastAmmoRegen > ammoRegenInterval && ammo < maxAmmo[powerUpLevel]) {
        ammo++;
        lastAmmoRegen = now;
        playSound(ammoRegenSound);
        vibrate(50);
        createParticle(shipX + shipWidth / 2, shipY + shipHeight / 2, false, '#ffff00');
      }

      let moving = false;
      const speed = currentSpeed * deltaTime * (window.innerWidth > 768 ? 1 : 0.8);
      if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
        shipX = Math.max(0, shipX - speed);
        moving = true;
      }
      if (keys['ArrowRight'] || keys['d'] || keys['D']) {
        shipX = Math.min(canvas.width - shipWidth, shipX + speed);
        moving = true;
      }
      if (keys['ArrowUp'] || keys['w'] || keys['W']) {
        shipY = Math.max(0, shipY - speed);
        moving = true;
      }
      if (keys['ArrowDown'] || keys['s'] || keys['S']) {
        shipY = Math.min(canvas.height - shipHeight, shipY + speed);
        moving = true;
      }

      if (moving) {
        if (!isThrusting) {
          thrustSound.volume = 0.3;
          thrustSound.play().catch(e => console.log('Erro ao tocar thrust:', e));
          isThrusting = true;
        }
        if (!wasMoving && Math.random() < 0.6) {
          createThrustParticle(shipX + shipWidth / 2, shipY);
        }
      } else {
        if (isThrusting) {
          thrustSound.pause();
          thrustSound.currentTime = 0;
          isThrusting = false;
        }
      }
      wasMoving = moving;

      if (keys[' '] && powerUpLevel > 0) {
        shoot();
        keys[' '] = false;
      }

      for (let s of stars) {
        const layerSpeed = (s.layer === 'distant' ? s.speed * 0.5 : s.layer === 'mid' ? s.speed * 0.8 : s.speed) * 1.2 * deltaTime;
        s.y += layerSpeed;
        if (s.y > canvas.height) s.y = 0;
        const dx = s.x - (shipX + shipWidth / 2);
        const dy = s.y - (shipY + shipHeight / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < s.size + shipWidth / 4) {
          score += 10;
          s.x = Math.random() * canvas.width;
          s.y = -10;
        }
      }

      // Atualizar lasers e colisões
      for (let i = lasers.length - 1; i >= 0; i--) {
        let l = lasers[i];
        l.y -= l.speed * deltaTime;
        // Colisões com asteroides (área varrida: entre shipY e l.y)
        for (let j = asteroids.length - 1; j >= 0; j--) {
          let a = asteroids[j];
          if (a.y < shipY && a.y > l.y) {
            destroyedMeteors++;
            score += 20 * powerUpLevel;
            ammo = Math.min(maxAmmo[powerUpLevel], ammo + 1);
            createExplosion(a.x, a.y, 12);
            playSound(explosionSound);
            vibrate(50);
            asteroids.splice(j, 1);
            if (destroyedMeteors % 5 === 0) {
              shieldCount = Math.min(5, shieldCount + 1);
              playSound(shieldSound);
              vibrate(100);
            }
          }
        }
        if (l.y < 0) {
          lasers.splice(i, 1);
        }
      }

      for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        b.x += b.vx * deltaTime;
        b.y += b.vy * deltaTime;
        if (b.y < 0 || b.x < 0 || b.x > canvas.width) {
          bullets.splice(i, 1);
          continue;
        }
        for (let j = asteroids.length - 1; j >= 0; j--) {
          let a = asteroids[j];
          const bdx = b.x - a.x;
          const bdy = b.y - a.y;
          const bdist = Math.sqrt(bdx * bdx + bdy * bdy);
          if (bdist < b.size + a.size) {
            destroyedMeteors++;
            score += 20 * powerUpLevel;
            ammo = Math.min(maxAmmo[powerUpLevel], ammo + 1);
            bullets.splice(i, 1);
            createExplosion(a.x, a.y, 12);
            playSound(explosionSound);
            vibrate(50);
            asteroids.splice(j, 1);
            if (destroyedMeteors % 5 === 0) {
              shieldCount = Math.min(5, shieldCount + 1);
              playSound(shieldSound);
              vibrate(100);
            }
            break;
          }
        }
      }

      for (let i = asteroids.length - 1; i >= 0; i--) {
        let a = asteroids[i];
        a.x += a.vx * deltaTime;
        a.y += a.speed * deltaTime;
        if (a.y > canvas.height) {
          asteroids.splice(i, 1);
          continue;
        }
        const dx = a.x - (shipX + shipWidth / 2);
        const dy = a.y - (shipY + shipHeight / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < a.size + shipWidth / 4) {
          // Regressão do modelo no impacto
          if (powerUpLevel > 1) {
            powerUpLevel--;
            ammo = Math.min(ammo, maxAmmo[powerUpLevel]);
            playSound(downgradeSound);
            vibrate(80);
            downgradeFlash = 30;
            for (let k = 0; k < 12; k++) {
              createParticle(shipX + shipWidth / 2, shipY + shipHeight / 2, false, '#ff0000');
            }
            createExplosion(shipX + shipWidth / 2, shipY + shipHeight / 2, 6);
          }

          let hitHandled = false;
          if (ammo > 0) {
            ammo--;
            createParticle(a.x, a.y, true, 'rgba(255, 165, 0, 0.5)');
            playSound(hitSound);
            vibrate(50);
            hitHandled = true;
          } else if (shieldCount > 0) {
            shieldCount--;
            createParticle(a.x, a.y, true, 'rgba(0,255,0,0.5)');
            playSound(shieldSound);
            vibrate(100);
            hitHandled = true;
          }
          if (!hitHandled) {
            lives--;
            createExplosion(shipX + shipWidth / 2, shipY + shipHeight / 2, 15);
            playSound(hitSound);
            vibrate(200);
            if (lives <= 0) {
              endGame();
              return;
            }
          }
          asteroids.splice(i, 1);
        }
      }

      for (let i = powerups.length - 1; i >= 0; i--) {
        let p = powerups[i];
        p.y += p.speed * deltaTime;
        if (p.y > canvas.height) {
          powerups.splice(i, 1);
          continue;
        }
        const dx = p.x - (shipX + shipWidth / 2);
        const dy = p.y - (shipY + shipHeight / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < p.size + shipWidth / 4) {
          const oldLevel = powerUpLevel;
          if (p.type === 'weapon') {
            powerUpLevel = Math.min(4, powerUpLevel + 1);
            ammo = Math.min(ammo, maxAmmo[powerUpLevel]);
          } else if (p.type === 'ammo') {
            ammo = maxAmmo[powerUpLevel];
            playSound(ammoRegenSound);
          } else {
            applyPowerUp(p.type);
          }
          powerups.splice(i, 1);
          playSound(powerupSound);
          vibrate(150);
          for (let k = 0; k < 6; k++) {
            createParticle(p.x, p.y, false);
          }
        }
      }

      if (Math.random() < asteroidSpawnRate * deltaTime) {
        const diagonalIntensity = Math.min(4, score / 500);
        const vx = (Math.random() - 0.5) * 2 * diagonalIntensity;
        asteroids.push({
          x: Math.random() * canvas.width,
          y: 0,
          size: Math.random() * 20 + 15,
          speed: Math.random() * maxAsteroidSpeed + 3,
          vx: vx,
          flames: []
        });
      }

      if (Math.random() < 0.002 * deltaTime) {
        const types = ['speed', 'shield', 'life', 'weapon', 'ammo'];
        const type = types[Math.floor(Math.random() * types.length)];
        powerups.push({
          x: Math.random() * canvas.width,
          y: 0,
          size: 18,
          speed: Math.random() * 2 + 1,
          type: type
        });
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let s of stars) {
        ctx.fillStyle = s.layer === 'distant' ? '#888' : s.layer === 'mid' ? '#bbb' : '#fff';
        ctx.globalAlpha = s.brightness;
        const r = s.layer === 'distant' ? s.size * 0.5 : s.layer === 'mid' ? s.size * 0.8 : s.size;
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      updateAsteroidFlames();
      drawAsteroidFlames();

      ctx.shadowColor = 'rgba(139, 69, 19, 0.8)';
      ctx.shadowBlur = 10;
      ctx.font = 'bold 20px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let a of asteroids) {
        ctx.font = `bold ${a.size * 1.2}px Arial, sans-serif`;
        ctx.fillStyle = '#8B4513';
        ctx.fillText('🪨', a.x, a.y);
      }
      ctx.shadowBlur = 0;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';

      bullets.forEach(b => {
        ctx.shadowColor = b.color;
        ctx.shadowBlur = 10;
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.rect(b.x - b.size / 2, b.y - b.size * 2, b.size, b.size * 4);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });

      // Desenhar lasers
      lasers.forEach(l => {
        ctx.save();
        ctx.shadowColor = l.color;
        ctx.shadowBlur = 15;
        ctx.strokeStyle = l.color;
        ctx.lineWidth = l.height;
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(l.x, l.y);
        ctx.lineTo(l.x + l.width, l.y);
        ctx.stroke();
        ctx.restore();
      });

      for (let p of powerups) {
        const pulseSize = p.size + Math.sin(Date.now() / 200) * 2;
        let shadowColor, fillColor, icon;
        switch (p.type) {
          case 'speed':
            shadowColor = '#00ffff';
            fillColor = 'rgba(0, 255, 255, 0.9)';
            icon = '🚀';
            break;
          case 'shield':
            shadowColor = '#00ff00';
            fillColor = 'rgba(0, 255, 0, 0.9)';
            icon = '🛡️';
            break;
          case 'life':
            shadowColor = '#ff0000';
            fillColor = 'rgba(255, 0, 0, 0.9)';
            icon = '❤️';
            break;
          case 'weapon':
            shadowColor = '#ffff00';
            fillColor = 'rgba(255, 255, 0, 0.9)';
            icon = '🔫';
            break;
          case 'ammo':
            shadowColor = '#00ff00';
            fillColor = 'rgba(0, 255, 0, 0.9)';
            icon = '🔋';
            break;
        }
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = 12;
        ctx.fillStyle = fillColor;
        ctx.beginPath();
        ctx.arc(p.x, p.y, pulseSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.font = `${Math.min(20, canvas.width / 50)}px Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(icon, p.x, p.y);
      }
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';

      drawThrustParticles();
      updateThrustParticles();

      updateExplosionParticles();
      drawExplosionParticles();

      const exhaustX = shipX + shipWidth / 2;
      const exhaustY = shipY + shipHeight;
      for (let i = 0; i < 5; i++) {
        createParticle(exhaustX, exhaustY - 5);
      }
      for (let i = 0; i < 1; i++) {
        createParticle(exhaustX, exhaustY - 5, true);
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= p.decay * 0.8;
        p.size *= p.isSmoke ? 0.99 : 0.96;
        p.vy += 0.1;
        p.rotation += p.isSmoke ? 0.05 : 0.1;
        if (p.alpha <= 0 || p.size <= 0.1 || p.y > canvas.height) particles.splice(i, 1);
      }

      particles.forEach(p => {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rotation);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.alpha;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 8;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
        if (!p.isSmoke && Math.random() < 0.3) {
          ctx.fillStyle = 'white';
          ctx.globalAlpha = p.alpha * 0.8;
          ctx.fillRect(-p.size / 4, -p.size / 4, p.size / 2, p.size / 2);
        }
        ctx.restore();
      });
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;

      rastro.style.left = `${exhaustX - 50}px`;
      rastro.style.top = `${exhaustY}px`;
      rastroCore.style.left = `${exhaustX - 10}px`;
      rastroCore.style.top = `${exhaustY}px`;

      let shieldColor = 'rgba(21, 94, 183, 1)';
      if (shieldCount === 1) {
        shieldColor = 'rgba(0, 255, 0, 1)';
      } else if (shieldCount === 2) {
        shieldColor = 'rgba(128, 0, 128, 1)';
      } else if (shieldCount === 3) {
        shieldColor = 'rgba(0, 0, 255, 1)';
      } else if (shieldCount >= 4) {
        shieldColor = 'rgba(255, 255, 0, 1)';
      }
      ctx.shadowColor = shieldActive ? shieldColor : 'rgba(21, 94, 183, 1)';
      ctx.shadowBlur = shieldActive ? 30 : 20;
      if (shipImg.complete) {
        ctx.drawImage(shipImg, shipX, shipY, shipWidth, shipHeight);
      }
      ctx.shadowBlur = 0;

      if (downgradeFlash > 0) {
        const flashAlpha = (downgradeFlash / 30) * 0.4;
        ctx.fillStyle = `rgba(255, 0, 0, ${flashAlpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      const uiScale = window.innerWidth > 768 ? 1 : 0.8;
      ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
      ctx.shadowBlur = 5;
      ctx.fillStyle = 'white';
      ctx.font = `bold ${Math.min(24, canvas.width / 30) * uiScale}px 'Poppins', sans-serif`;
      ctx.textAlign = 'left';
      ctx.fillText(`PONTOS: ${score}`, 20, 40);
      ctx.fillText(`VIDAS: ${'❤️'.repeat(lives)}`, 20, 70);
      ctx.fillText(`TIROS: ${ammo}/${maxAmmo[powerUpLevel]}`, 20, 100);
      ctx.fillText(`MODELO: ${powerUpLevel}`, 20, 130);
      ctx.fillText(`ESCUDOS: ${'🛡️'.repeat(shieldCount)}`, 20, 160);
      ctx.shadowBlur = 0;
      ctx.textAlign = 'left';

      rafIdGame = requestAnimationFrame(gameLoop);
    }

    function applyPowerUp(type) {
      const currentTime = Date.now();
      if (type === 'speed') {
        speedBoostEndTime = currentTime + 5000;
      } else if (type === 'shield') {
        shieldCount = Math.min(5, shieldCount + 1);
      } else if (type === 'life') {
        lives = Math.min(5, lives + 1);
        if (lives % 5 === 0) {
          shieldCount = Math.min(5, shieldCount + 1);
          playSound(shieldSound);
        }
      }
    }

    function endGame(forceResume = false) {
      gameActive = false;
      cancelAnimationFrame(rafIdGame);
      thrustSound.pause();
      thrustSound.currentTime = 0;
      isThrusting = false;
      rafIdStars = requestAnimationFrame(drawStars);
      rafIdParticles = requestAnimationFrame(updateParticles);
      if (!forceResume) {
        // Animação do logo sobrevoando a tela
        logo.style.opacity = '1';
        logo.style.position = 'relative';
        logo.style.zIndex = '15';
        logo.style.animation = 'logoFlyover 4s ease-in-out forwards';

        // Após a animação do logo (4s), mostrar overlay
        setTimeout(() => {
          gameOverOverlay.style.display = 'flex';
          gameOverOverlay.style.opacity = '0';
          setTimeout(() => {
            gameOverOverlay.style.opacity = '1';
            gameOverOverlay.classList.add('show');
            const scoreEl = gameOverOverlay.querySelector('.score');
            scoreEl.style.opacity = '0';
            scoreEl.style.transform = 'scale(0.5)';
            scoreEl.style.transition = 'all 0.8s cubic-bezier(0.25, 0.8, 0.25, 1)';
            scoreEl.textContent = score;
            setTimeout(() => {
              scoreEl.style.opacity = '1';
              scoreEl.style.transform = 'scale(1)';
            }, 100);
          }, 300);

          // Após exibir score, animação para o Ranking TOP 5
          setTimeout(() => {
            fetchTop5(score);
          }, 2000);
        }, 4000); // 4s para a animação do logo
      } else {
        logo.style.opacity = '1';
        logo.style.animation = 'none';
        logo.style.position = 'relative';
        logo.style.left = 'auto';
        logo.style.top = 'auto';
        logo.style.zIndex = '5';
        gameOverOverlay.style.display = 'none';
        buttonContainer.style.display = 'flex';
        buttonContainer.style.opacity = '1';
      }
    }

    function restartGame() {
      gameOverOverlay.style.display = 'none';
      gameOverOverlay.classList.remove('show');
      document.getElementById('nameInput').style.display = 'none';
      document.getElementById('nameInput').innerHTML = '';
      document.getElementById('top5').classList.remove('animate-ranking');
      startGame();
    }

    function exitGame() {
      endGame(true);
      ambientSound.pause();
      ambientSound.currentTime = 0;
    }

    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'g') {
        e.preventDefault();
        if (!gameActive) {
          startGame();
        }
      } else if (e.key === 'Escape' && gameActive) {
        endGame(true);
      } else if (gameActive) {
        keys[e.key] = true;
        if (e.key === ' ') e.preventDefault();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (gameActive) {
        keys[e.key] = false;
      }
    });

    document.addEventListener('touchstart', (e) => {
      if (gameActive) {
        e.preventDefault();
        touchActive = true;
        updateShipPos(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (gameActive && touchActive) {
        e.preventDefault();
        updateShipPos(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (gameActive) {
        touchActive = false;
        const now = Date.now();
        if (now - doubleClickTimer < 300) {
          shoot();
        }
        doubleClickTimer = now;
      }
    }, { passive: false });

    function updateShipPos(tx, ty) {
      shipX = Math.max(0, Math.min(canvas.width - shipWidth, tx - shipWidth / 2));
      shipY = Math.max(0, Math.min(canvas.height - shipHeight, ty - shipHeight / 2));
      const exhaustX = shipX + shipWidth / 2;
      const exhaustY = shipY + shipHeight;
      rastro.style.left = `${exhaustX - 50}px`;
      rastro.style.top = `${exhaustY}px`;
      rastroCore.style.left = `${exhaustX - 10}px`;
      rastroCore.style.top = `${exhaustY}px`;
    }

    document.addEventListener('dblclick', (e) => {
      if (gameActive && powerUpLevel > 0) {
        e.preventDefault();
        shoot();
      }
    });

    logo.addEventListener('click', (e) => {
      if (gameActive) return;
      const now = Date.now();
      if (now - doubleClickTimer < 300) {
        startGame();
      }
      doubleClickTimer = now;
    });

    function triggerExitSequence() {
      logo.style.animation = 'zoomLogo 2s ease-in forwards';
      canvas.style.animation = 'cameraZoom 2s ease-in forwards';
      hyperdriveActive = true;
      stars.forEach(s => s.isHyper = Math.random() < 0.8);
      document.getElementById('hyperdrive').style.opacity = '0.6';
      buttonContainer.style.display = 'none';

      setTimeout(() => {
        document.querySelector('#text1').style.transition = 'opacity 1s ease-out, transform 1s ease-out';
        document.querySelector('#text2').style.transition = 'opacity 1s ease-out, transform 1s ease-out';
        document.querySelector('#text1').style.opacity = '0';
        document.querySelector('#text2').style.opacity = '0';
        document.querySelector('#text1').style.transform = 'translateY(30px)';
        document.querySelector('#text2').style.transform = 'translateY(30px)';
      }, 1000);

      setTimeout(() => {
        overlay.style.opacity = '0.5';
        setTimeout(() => {
          overlay.style.opacity = '1';
        }, 300);
      }, 2500);

      setTimeout(() => {
  window.location.href = 'https://search.google.com/local/writereview?placeid=ChIJj8QLZ3VNz5QR6fyhf_lxpkM';
}, 1700);
    }

    setTimeout(() => {
      const rect = logo.getBoundingClientRect();
      flare.style.left = `${rect.left + rect.width / 2 - 100}px`;
      flare.style.top = `${rect.top + rect.height / 2 - 100}px`;
      flare.style.animation = 'flareEffect 0.5s ease-out forwards';
    }, 1000);

    rafIdStars = requestAnimationFrame(drawStars);
    rafIdParticles = requestAnimationFrame(updateParticles);
  </script>
</body>
</html>